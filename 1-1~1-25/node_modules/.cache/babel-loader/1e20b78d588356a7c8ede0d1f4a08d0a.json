{"ast":null,"code":"var _jsxFileName = \"C:\\\\react\\\\study_react\\\\src\\\\UserList.js\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useRef, useContext } from 'react';\nimport { UserDispatch } from './App'; // Array.prototype.map() 을 통해 호출되는 함수\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst User = /*#__PURE__*/React.memo(_c = _s(function User({\n  user\n}) {\n  _s();\n\n  const dispatch = useContext(UserDispatch);\n  /* \r\n  useEffect : 컴포넌트 랜더링 때마다 특정 작업 실행할 수 있도록 하는 Hook -> useEffect(function, deps)\r\n    1. Component가 mount 되었을 때 (나타났을 때)\r\n  - Component가 가장 처음 렌더링 되었을 때 한 번만 실행하려면, deps 위치에 빈 배열을 넣는다\r\n  - Component가 렌더링 될 때마다 실행하려면, deps 위치에 아무것도 안 넣으면 된다\r\n    2. Component가 업데이트 될 때 (특정 props, state가 바뀔 때)\r\n  - 특정 props, state 값이 변경되었을 때 실행하려면, deps 위치에 변화를 검사할 값을 집어넣으면 된다\r\n  - deps 값이 업데이트 될 때만 지정한 작업을 실행하려면, 아래의 예시를 참고하면 좋다\r\n    3. Component가 unmount 되었을 때 (사라질 때) & update 되기 직전에\r\n  - cleanup 함수가 반환되며, 이는 return 뒤에 나오는 함수를 의미한다.\r\n  - unmount 될 때에만 cleanup 함수를 실행하고 싶을 경우, deps 위치에 빈 배열을 넣는다\r\n  */\n  // 예시 : deps 값이 업데이트 될 때만 지정한 작업 실행\n\n  const isMounted = useRef(false);\n  useEffect(() => {\n    // deps 값이 있으므로 가장 첫 렌더링만 신경써주면 된다\n    if (!isMounted.current) {\n      isMounted.current = true;\n    } else {\n      console.log('deps 값이 업데이트됨');\n    }\n  }, [user]);\n  return (\n    /*#__PURE__*/\n    // jsx 외부에서 정의 된 event handler/callback은 파라미터를 넘겨줄 시 화살표 함수를 사용하여야 한다.\n    _jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"b\", {\n        style: {\n          cursor: 'pointer',\n          color: user.active ? 'green' : 'black'\n        },\n        onClick: () => {\n          dispatch({\n            type: 'TOGGLE_USER',\n            id: user.id\n          });\n        },\n        children: [\" \", user.username, \" \"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 38,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"span\", {\n        children: [\"(\", user.email, \")\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 45,\n        columnNumber: 13\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          dispatch({\n            type: 'REMOVE_USER',\n            id: user.id\n          });\n        },\n        children: \"\\uC0AD\\uC81C\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 46,\n        columnNumber: 13\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 37,\n      columnNumber: 9\n    }, this)\n  );\n}, \"szNEQf7cq1fV4E92Y0UnetPlnQU=\"));\n_c2 = User;\n\nfunction UserList({\n  users\n}) {\n  // 렌더링 확인용\n  console.log('UserList.js가 렌더링됨');\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: users.map(user => /*#__PURE__*/_jsxDEV(User, {\n      user: user\n    }, user.id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 65,\n      columnNumber: 17\n    }, this))\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 57,\n    columnNumber: 9\n  }, this);\n}\n\n_c3 = UserList;\nexport default _c4 = /*#__PURE__*/React.memo(UserList);\n\nvar _c, _c2, _c3, _c4;\n\n$RefreshReg$(_c, \"User$React.memo\");\n$RefreshReg$(_c2, \"User\");\n$RefreshReg$(_c3, \"UserList\");\n$RefreshReg$(_c4, \"%default%\");","map":{"version":3,"sources":["C:/react/study_react/src/UserList.js"],"names":["React","useEffect","useRef","useContext","UserDispatch","User","memo","user","dispatch","isMounted","current","console","log","cursor","color","active","type","id","username","email","UserList","users","map"],"mappings":";;;AAAA,OAAOA,KAAP,IAAeC,SAAf,EAA0BC,MAA1B,EAAkCC,UAAlC,QAAmD,OAAnD;AACA,SAAQC,YAAR,QAA2B,OAA3B,C,CAEA;;;AACA,MAAMC,IAAI,gBAAGL,KAAK,CAACM,IAAN,SAAW,SAASD,IAAT,CAAc;AAACE,EAAAA;AAAD,CAAd,EAAsB;AAAA;;AAC1C,QAAMC,QAAQ,GAAGL,UAAU,CAACC,YAAD,CAA3B;AAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKI;;AACA,QAAMK,SAAS,GAAGP,MAAM,CAAC,KAAD,CAAxB;AACAD,EAAAA,SAAS,CAAC,MAAM;AACZ;AACA,QAAI,CAACQ,SAAS,CAACC,OAAf,EAAwB;AACpBD,MAAAA,SAAS,CAACC,OAAV,GAAoB,IAApB;AACH,KAFD,MAEO;AACHC,MAAAA,OAAO,CAACC,GAAR,CAAY,eAAZ;AACH;AACJ,GAPQ,EAOP,CAACL,IAAD,CAPO,CAAT;AASA;AAAA;AACI;AACA;AAAA,8BACI;AAAG,QAAA,KAAK,EAAE;AACNM,UAAAA,MAAM,EAAE,SADF;AAENC,UAAAA,KAAK,EAAEP,IAAI,CAACQ,MAAL,GAAc,OAAd,GAAwB;AAFzB,SAAV;AAIA,QAAA,OAAO,EAAI,MAAM;AACbP,UAAAA,QAAQ,CAAC;AAACQ,YAAAA,IAAI,EAAE,aAAP;AAAsBC,YAAAA,EAAE,EAAEV,IAAI,CAACU;AAA/B,WAAD,CAAR;AACH,SAND;AAAA,wBAMKV,IAAI,CAACW,QANV;AAAA;AAAA;AAAA;AAAA;AAAA,cADJ,eAQI;AAAA,wBAAQX,IAAI,CAACY,KAAb;AAAA;AAAA;AAAA;AAAA;AAAA,cARJ,eASI;AAAQ,QAAA,OAAO,EAAE,MAAM;AACnBX,UAAAA,QAAQ,CAAC;AAACQ,YAAAA,IAAI,EAAE,aAAP;AAAsBC,YAAAA,EAAE,EAAEV,IAAI,CAACU;AAA/B,WAAD,CAAR;AACH,SAFD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cATJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAFJ;AAgBH,CA9CY,kCAAb;MAAMZ,I;;AAgDN,SAASe,QAAT,CAAkB;AAACC,EAAAA;AAAD,CAAlB,EAA2B;AACvB;AACAV,EAAAA,OAAO,CAACC,GAAR,CAAY,mBAAZ;AACA,sBACI;AAAA,cAOKS,KAAK,CAACC,GAAN,CAAUf,IAAI,iBACX,QAAC,IAAD;AACI,MAAA,IAAI,EAAEA;AADV,OAESA,IAAI,CAACU,EAFd;AAAA;AAAA;AAAA;AAAA,YADH;AAPL;AAAA;AAAA;AAAA;AAAA,UADJ;AAgBH;;MAnBQG,Q;AAqBT,kCAAepB,KAAK,CAACM,IAAN,CAAWc,QAAX,CAAf","sourcesContent":["import React, {useEffect, useRef, useContext} from 'react';\r\nimport {UserDispatch} from './App';\r\n\r\n// Array.prototype.map() 을 통해 호출되는 함수\r\nconst User = React.memo(function User({user}) {\r\n    const dispatch = useContext(UserDispatch);\r\n\r\n    /* \r\n    useEffect : 컴포넌트 랜더링 때마다 특정 작업 실행할 수 있도록 하는 Hook -> useEffect(function, deps)\r\n\r\n    1. Component가 mount 되었을 때 (나타났을 때)\r\n    - Component가 가장 처음 렌더링 되었을 때 한 번만 실행하려면, deps 위치에 빈 배열을 넣는다\r\n    - Component가 렌더링 될 때마다 실행하려면, deps 위치에 아무것도 안 넣으면 된다\r\n\r\n    2. Component가 업데이트 될 때 (특정 props, state가 바뀔 때)\r\n    - 특정 props, state 값이 변경되었을 때 실행하려면, deps 위치에 변화를 검사할 값을 집어넣으면 된다\r\n    - deps 값이 업데이트 될 때만 지정한 작업을 실행하려면, 아래의 예시를 참고하면 좋다\r\n\r\n    3. Component가 unmount 되었을 때 (사라질 때) & update 되기 직전에\r\n    - cleanup 함수가 반환되며, 이는 return 뒤에 나오는 함수를 의미한다.\r\n    - unmount 될 때에만 cleanup 함수를 실행하고 싶을 경우, deps 위치에 빈 배열을 넣는다\r\n    */\r\n\r\n    // 예시 : deps 값이 업데이트 될 때만 지정한 작업 실행\r\n    const isMounted = useRef(false);\r\n    useEffect(() => {\r\n        // deps 값이 있으므로 가장 첫 렌더링만 신경써주면 된다\r\n        if (!isMounted.current) {\r\n            isMounted.current = true;\r\n        } else {\r\n            console.log('deps 값이 업데이트됨');\r\n        }\r\n    },[user]);\r\n\r\n    return(\r\n        // jsx 외부에서 정의 된 event handler/callback은 파라미터를 넘겨줄 시 화살표 함수를 사용하여야 한다.\r\n        <div>\r\n            <b style={{\r\n                cursor: 'pointer',\r\n                color: user.active ? 'green' : 'black'\r\n            }}\r\n            onClick = {() => {\r\n                dispatch({type: 'TOGGLE_USER', id: user.id});\r\n            }}> {user.username} </b>\r\n            <span>({user.email})</span>\r\n            <button onClick={() => {\r\n                dispatch({type: 'REMOVE_USER', id: user.id})\r\n            }}>삭제</button>\r\n        </div>\r\n    );\r\n});\r\n\r\nfunction UserList({users}) {\r\n    // 렌더링 확인용\r\n    console.log('UserList.js가 렌더링됨')\r\n    return (\r\n        <div>\r\n            {/* Array.prototype.map() : 배열 내의 모든 요소에 대해 함수를 호출한 결과를 모아 새로운 배열을 만듦*/}\r\n            {/* key를 지정하면 효율적인 업데이트 방식을 영위하므로 되도록이면 꼭 지정하는 것이 좋다 */}\r\n            {/* id값이 없다면 index값을 key로 지정하면 된다 */}\r\n            {/* {users.map((user,index) => (\r\n                <User user={user} key={index} />\r\n            ))} */}\r\n            {users.map(user => (\r\n                <User\r\n                    user={user}\r\n                    key={user.id}\r\n                />\r\n            ))}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default React.memo(UserList);"]},"metadata":{},"sourceType":"module"}